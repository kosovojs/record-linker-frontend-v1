# Comprehensive React Application Architecture Guide (2025 Edition)

This document serves as the **definitive architectural blueprint** for the project. It synthesizes modern best practices (Feature-First, Vertical Slicing) into a practical, scalable guide. It is designed to minimize decision fatigue by providing clear rules for where code belongs and how it should interact.

---

## 1. Core Philosophy: The "Vertical Slice" (Feature-First)

In a traditional "Layered" architecture, you might have top-level folders like `controllers`, `views`, and `models`. In React, this translates to `components`, `hooks`, and `utils`. While simple, this breaks down as the app grows. You end up jumping between 5 different folders to build one feature.

**We adopt a Feature-First (Vertical Slice) Architecture.**

*   **Principle:** Group code by **business domain** (what it does), not by **technical role** (what it is).
*   **The Test:** You should be able to delete the `src/features/dashboard` folder, and the only thing lost is the Dashboard. The rest of the app should compile and run perfectly (minus the route).
*   **Encapsulation:** Features are "mini-apps". They have their own routes, state, and API services.

---

## 2. The Master Directory Structure

Adhere strictly to this structure.

```text
src/
├── app/                        # Application Bootstrap & Configuration
│   ├── store.js                # Global Redux store setup
│   ├── router.jsx              # Central Route definitions
│   ├── App.jsx                 # Root component (Providers, Global Suspense)
│   └── main.jsx                # Entry point (ReactDOM.render)
├── assets/                     # Static Assets
│   ├── fonts/
│   ├── images/
│   └── styles/                 # Global CSS/Tailwind layers
├── components/                 # SHARED, GENERIC UI Components
│   ├── ui/                     # VENDOR Primitives (Shadcn/HeadlessUI) - DO NOT EDIT LOGIC
│   ├── common/                 # APP Primitives (LoadingSpinner, ErrorBoundary)
│   └── layout/                 # Structural Components (MainLayout, AuthLayout)
├── features/                   # BUSINESS LOGIC (Vertical Slices)
│   ├── auth/                   # Authentication Domain
│   │   ├── components/         # LoginBox, RegisterForm
│   │   ├── hooks/              # useAuth, useLogin
│   │   ├── services/           # auth.api.js (API endpoints)
│   │   └── store/              # authSlice.js
│   ├── dashboard/              # Dashboard Domain
│   │   ├── components/         # DashboardWidget, RevenueChart
│   │   ├── pages/              # DashboardPage.jsx (The Route Target)
│   │   └── ...
│   └── users/                  # User Management Domain
├── hooks/                      # Global Hooks (Feature-agnostic)
│   ├── useDebounce.js
│   ├── useLocalStorage.js
│   └── useMediaQuery.js
├── lib/                        # Third-party Library Configurations
│   ├── axios.js                # (If using axios)
│   ├── firebase.js             # (If using firebase)
│   └── utils.js                # cn() helper for Tailwind
├── services/                   # Global Integration Layer
│   ├── api/
│   │   ├── client.js           # Central Fetch Wrapper (The "Gateway")
│   │   └── types.js            # Shared API interfaces
│   └── storage/                # LocalStorage/SessionStorage wrappers
└── utils/                      # Pure Helper Functions (Business-agnostic)
    ├── date-formatters.js
    └── validators.js
```

---

## 3. Deep Dive: Component Categories

Confusion often arises between "UI components" and "Feature components". Here is the strict distinction:

### A. `src/components/ui/` (The Design System)
*   **Source:** Usually generated by CLI (e.g., `shadcn-ui`).
*   **Nature:** Dumb, purely presentational, highly reusable.
*   **Rules:**
    *   **NEVER** add business logic (Redux, API calls) here.
    *   **NEVER** change the file structure if generated by a tool.
    *   *Examples:* `Button.jsx`, `Input.jsx`, `Dialog.jsx`, `Sheet.jsx`.

### B. `src/components/common/` (The Shared Toolkit)
*   **Source:** Hand-written by you.
*   **Nature:** Composite components used across multiple features.
*   **Rules:**
    *   Can compose `ui` components.
    *   Must accept data via props (minimize global state dependency).
    *   *Examples:* `PageHeader.jsx`, `DataTable.jsx` (generic wrapper), `ConfirmActionDialog.jsx`.

### C. `src/features/{name}/components/` (The Business Blocks)
*   **Source:** Hand-written, specific to a domain.
*   **Nature:** "Smart" components. They know about the domain data structure.
*   **Rules:**
    *   Can connect to Redux.
    *   Can trigger feature-specific actions.
    *   *Examples:* `UserProfileCard.jsx` (knows what a "User" looks like), `RecentTransactionsList.jsx`.

---

## 4. State Management Strategy (Redux Toolkit)

We do not dump everything into Redux. We use the right tool for the job.

1.  **Server State (API Data):**
    *   Prefer **TanStack Query (React Query)** if possible.
    *   If using Redux, use **RTK Query** or standard Async Thunks with a normalized `status` field.
2.  **Global Client State (Auth, Theme):**
    *   **Redux.** Perfect for data needed everywhere (User Profile, Dark Mode preference).
3.  **Local UI State (Form inputs, Sidebar toggle):**
    *   **React `useState` / `useReducer`.** Do not put form inputs in Redux unless strictly necessary for multi-step persistence.
4.  **Form State:**
    *   **React Hook Form.** Do not manage complex form validation state manually.

### The "Auth Slice" Pattern
Handling authentication requires a robust state machine to avoid "flashing" login screens.

```javascript
// src/features/auth/store/authSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { authService } from '../services/auth.service';

export const initializeApp = createAsyncThunk('auth/init', async () => {
  const token = localStorage.getItem('token');
  if (!token) return null;
  // Verify token validity with backend
  return await authService.getMe();
});

const initialState = {
  user: null,
  token: localStorage.getItem('token'),
  // 'idle' | 'initializing' | 'authenticated' | 'unauthenticated'
  status: 'idle', 
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.status = 'unauthenticated';
      localStorage.removeItem('token');
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(initializeApp.pending, (state) => {
        state.status = 'initializing';
      })
      .addCase(initializeApp.fulfilled, (state, action) => {
        if (action.payload) {
          state.user = action.payload;
          state.status = 'authenticated';
        } else {
          state.status = 'unauthenticated';
        }
      })
      .addCase(initializeApp.rejected, (state) => {
        state.status = 'unauthenticated';
        state.token = null;
        localStorage.removeItem('token');
      });
  },
});
```

---

## 5. The API Layer (Centralized Fetch)

Components **never** call `fetch()` directly. They use services, which use a central client.

### Level 1: The Client (`src/services/api/client.js`)
This is the "Gatekeeper". It handles:
1.  **Base URL injection.**
2.  **Auth Token injection** (Interceptors).
3.  **Global Error Handling** (401 Redirects, 500 Toasts).

```javascript
// src/services/api/client.js
const BASE_URL = import.meta.env.VITE_API_URL || '/api/v1';

export const apiClient = {
  async request(endpoint, { method = 'GET', data, ...customConfig } = {}) {
    const token = localStorage.getItem('token');
    
    const config = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
        ...customConfig.headers,
      },
      ...customConfig,
    };

    if (data) {
      config.body = JSON.stringify(data);
    }

    try {
      const response = await fetch(`${BASE_URL}${endpoint}`, config);

      // Automatic 401 Handling
      if (response.status === 401) {
        // Broadcast a logout event or redirect
        window.dispatchEvent(new Event('auth:logout'));
        return Promise.reject(new Error('Unauthorized'));
      }

      const responseData = await response.json().catch(() => ({}));

      if (!response.ok) {
        throw new Error(responseData.message || `HTTP Error ${response.status}`);
      }

      return responseData;
    } catch (error) {
      console.error('API Error:', error);
      throw error;
    }
  },

  // Shorthands
  get: (url, config) => apiClient.request(url, { ...config, method: 'GET' }),
  post: (url, data, config) => apiClient.request(url, { ...config, method: 'POST', data }),
  put: (url, data, config) => apiClient.request(url, { ...config, method: 'PUT', data }),
  delete: (url, config) => apiClient.request(url, { ...config, method: 'DELETE' }),
};
```

### Level 2: The Service (`src/features/dashboard/services/dashboard.service.js`)
These files map specific business actions to API endpoints.

```javascript
import { apiClient } from '@/services/api/client';

export const dashboardService = {
  getStats: async (period) => {
    return apiClient.get(`/dashboard/stats?period=${period}`);
  },
  
  updateWidgetLayout: async (layout) => {
    return apiClient.put('/dashboard/layout', layout);
  }
};
```

---

## 6. Routing and Pages

We use **Layout Routes** to manage common UI shells (Sidebar, Navbar) and **Guard Components** to protect routes.

### The Page Component (`src/features/dashboard/pages/DashboardPage.jsx`)
A "Page" is a Controller. It orchestrates.

```javascript
import { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchDashboardStats } from '../store/dashboardSlice';
import { StatsWidget } from '../components/StatsWidget';
import { RevenueChart } from '../components/RevenueChart';

export default function DashboardPage() {
  const dispatch = useDispatch();
  const { stats, status } = useSelector((state) => state.dashboard);

  useEffect(() => {
    dispatch(fetchDashboardStats('30d'));
  }, [dispatch]);

  if (status === 'loading') return <div className="p-8">Loading stats...</div>;

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold">Overview</h1>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
         <StatsWidget title="Total Users" value={stats.users} />
         <StatsWidget title="Revenue" value={stats.revenue} />
         <StatsWidget title="Active Sessions" value={stats.sessions} />
      </div>
      <RevenueChart data={stats.revenueHistory} />
    </div>
  );
}
```

### The Router (`src/app/router.jsx`)

```javascript
import { createBrowserRouter, Navigate } from 'react-router-dom';
import { MainLayout } from '@/components/layout/MainLayout';
import { AuthLayout } from '@/components/layout/AuthLayout';
import { ProtectedRoute } from '@/features/auth/components/ProtectedRoute';

// Lazy load pages for performance
const DashboardPage = React.lazy(() => import('@/features/dashboard/pages/DashboardPage'));
const LoginPage = React.lazy(() => import('@/features/auth/pages/LoginPage'));

export const router = createBrowserRouter([
  {
    path: '/',
    element: <ProtectedRoute><MainLayout /></ProtectedRoute>,
    children: [
      {
        path: 'dashboard',
        element: <DashboardPage />,
      },
      // ... other protected routes
    ],
  },
  {
    path: '/auth',
    element: <AuthLayout />,
    children: [
      { path: 'login', element: <LoginPage /> },
    ],
  },
  {
    path: '*',
    element: <Navigate to="/dashboard" replace />,
  }
]);
```

---

## 7. Decision Flowchart: "Where does this file go?"

When creating a new file, ask these questions in order:

1.  **Is it a UI Component?**
    *   **Yes:** Is it a generic HTML primitive (Button/Input)? -> `src/components/ui/`
    *   **Yes:** Is it a generic composite (ConfirmDialog)? -> `src/components/common/`
    *   **Yes:** Is it specific to a feature (UserProfile)? -> `src/features/user/components/`

2.  **Is it Business Logic / State?**
    *   **Yes:** Does it belong to a specific feature? -> `src/features/{name}/store/` or `hooks/`
    *   **Yes:** Is it global (Theme/Toast)? -> `src/app/store/` or `src/hooks/`

3.  **Is it an API Call?**
    *   **Yes:** Put it in `src/features/{name}/services/{name}.service.js`.

4.  **Is it a Helper Function?**
    *   **Yes:** Is it pure JS (formatting date)? -> `src/utils/`
    *   **Yes:** Does it use React Hooks? -> `src/hooks/`

---

## 8. Naming Conventions

*   **Directories:** `kebab-case` (e.g., `user-profile`, `data-table`)
*   **Components:** `PascalCase` (e.g., `UserProfile.jsx`, `SubmitButton.jsx`)
*   **Hooks:** `camelCase`, start with 'use' (e.g., `useAuth.js`)
*   **Functions/Variables:** `camelCase` (e.g., `fetchUserData`, `isLoading`)
*   **Constants:** `UPPER_SNAKE_CASE` (e.g., `API_BASE_URL`, `DEFAULT_TIMEOUT`)